\documentclass[10pt,a4paper,titlepage,oneside]{article}
\usepackage{LabProtocol}
\usepackage{tikz}
\usepackage{enumitem}
\usepackage{hyperref} 

\usepackage{wrapfig}
\usepackage{multirow}
\usepackage{tabularx}
\usepackage[naustrian]{babel}

\usetikzlibrary{arrows,automata} 

\exercise{}

% enter your data here
\authors{
	Daniel Zainzinger, Matr. Nr. 11777778 \\Noah Bruns, Matr. Nr. 11777778\par
	{\small e11777778@student.tuwien.ac.at\\ e11777778@student.tuwien.ac.at} \par
}


\begin{document} 

\maketitle  
 
\tableofcontents
\newpage  
\section{Einleitung}
Für das Programmieren mit mehreren Prozessoren ist es oft erforderlich, eine gemeinsame Datenstruktur zu verwenden. 
Eine möglichkeit ist List based Set. Dabei handelt es sich um eine Liste, bei welcher jedes Element einen Key besitzt.
Dieser Key ist eindeutig und die gesamte Liste ist anhand des Schlüssel sortiert. 
Um das Testen und Benchmarken der Datenstrukturen einfach zu halten, werden nur positive Integer Werte in die Datenstruktur
eingefügt (siehe \ref{bench:aufbau}).

\section{List-based set with coarse-grained locks}
\section{List-based set with fine-grained locks}
\section{List-based set with optimistic synchronization}
\section{List-based set with lazy synchronization}
\section{Lock-free list-based set}
\subsection{Verbesserungen}
In der \textit{find} Funktion wird für das Auslinken eines Nodes wird ein Compare and Swap(CAS) verwendet. Falls dies fehlschlägt, 
weil z.b. der Node zum beispiel bereits ausgelinkt wurde,
wird wieder beim Listenkopf begonnen. Um dieses Verhalten zu verbessern, wurde in \textit{Lock\_free\_impr.cpp} folgendes implementiert:\\
Es wird immer der alte \textit{predecessor} gespeichert. Sollte CAS fehlschlagen, wird überprüft ob der alte \textit{predecessor}
zum auslinken markiert wurde. Ist dies der Fall, werden \textit{predecessor, current} und \textit{successor} auf den jeweiligen Vorgänger
gesetzt und an dieser Stelle weitergemacht. 

\input{MemmoryManagment.tex} 
\input{Benchmark.tex} 

	


		

\end{document}
