\documentclass[10pt,a4paper,titlepage,oneside]{article}
\usepackage{LabProtocol}
\usepackage{tikz}
\usepackage{enumitem}
\usepackage{hyperref} 

\usepackage{wrapfig}
\usepackage{multirow}
\usepackage{tabularx}
\usepackage[naustrian]{babel}

\usetikzlibrary{arrows,automata} 

\exercise{}

% enter your data here
\authors{
	Daniel Zainzinger, Matr. Nr. 11777778 \\Noah Bruns, Matr. Nr. 11777778\par
	{\small e11777778@student.tuwien.ac.at\\ e11777778@student.tuwien.ac.at} \par
}


\begin{document} 

\maketitle  
 
\tableofcontents
\newpage  
\section{Einleitung}
Für das Programmieren mit mehreren Prozessoren ist es oft erforderlich, eine gemeinsame Datenstruktur zu verwenden. 
Eine möglichkeit ist List based Set. Dabei handelt es sich um eine Liste, bei welcher jedes Element einen Key besitzt.
Dieser Key ist eindeutig und die gesamte Liste ist anhand des Schlüssel sortiert. 
Um das Testen und Benchmarken der Datenstrukturen einfach zu halten, werden nur positive Integer Werte in die Datenstruktur eingefügt (siehe \ref{bench:aufbau}).

\section{List-based set with coarse-grained locks}

Bei dieser Implementierung wir vor jedem Methodenaufruf die gesammte Liste gesperrt. Dadurch kann aber die Parallelisierung nicht wirklich ausgenutzt werden, da zu einem Zeitpunkt maximal ein Process auf die Liste zugreifen kann. Daher ähnelt diese Version einer sequentiellen Implementierung.

\subsection{Linearisation Point}

\subsection{Methods:}
\textbf{add}\\
\textbf{contains}\\
\textbf{remove}

\section{List-based set with fine-grained locks}

Im unterschied zu den coarse-grained locks wird bei dieser Implementierung immer nur die derzeitige Node gesprerrt. Beim Iterieren der Liste wird während dem Übergang zur nächsten Node die derzeitige und die darauffolgende Node gesperrt. Der Vorteil gegenüber den coarse-grained locks besteht darin, dass nun wirkliche Parallelisierung möglich ist und verschidene Threads an unterschiedlichen Punkten an der Liste arbeiten können.

\subsection{Linearisation Point}

\subsection{Methods:}
\textbf{add}\\
\textbf{contains}\\
\textbf{remove}

\section{List-based set with optimistic synchronization}

In dieser Implementierung wird beim Suchen eines ELementes zuerst keine Node gesperrt sonder einfach nur eine Iteration durchgeführt. Sobald das gesuchte gefunden wurde wird dieses gesperrt und sichergestellt, dass diese Node immernoch erreichbar ist. Falls dies nicht der Fall sein sollte wird startet der Algorithmus von vorne.

\subsection{Linearisation Point}

\subsection{Methods:}
\textbf{add}\\
\textbf{contains}\\
\textbf{remove}

\section{List-based set with lazy synchronization}

Lazy Synchronization verwendet eine Markierung auf den Nodes die bekannt gibt ob diese Node noch aktiv ist oder nicht. Bei einem Lösch Vorgang wird bei der zu löschenden Node diese Markierung gesetzt. Dadurch wird diese Node bei anderen Methoden, wie zum Beispiel Contains oder Add, ignoriert. 

In späterer folge wird durch das Memory management, ähnlich wie bei optimistic synchronization, die Node gelöscht sobald sichergestellt werden kann, dass kein Process mehr auf die Node zugreift.

\subsection{Linearisation Point}

\subsection{Methods:}
\textbf{add}\\
\textbf{contains}\\
\textbf{remove}

\section{Lock-free list-based set}

\subsection{Linearisation Point}

\subsection{Methods:}
\textbf{add}\\
\textbf{contains}\\
\textbf{remove}



\subsection{Verbesserungen}
In der \textit{find} Funktion wird für das Auslinken eines Nodes wird ein Compare and Swap(CAS) verwendet. Falls dies fehlschlägt, 
weil z.b. der Node zum beispiel bereits ausgelinkt wurde,
wird wieder beim Listenkopf begonnen. Um dieses Verhalten zu verbessern, wurde in \textit{Lock\_free\_impr.cpp} folgendes implementiert:\\
Es wird immer der alte \textit{predecessor} gespeichert. Sollte CAS fehlschlagen, wird überprüft ob der alte \textit{predecessor}
zum auslinken markiert wurde. Ist dies der Fall, werden \textit{predecessor, current} und \textit{successor} auf den jeweiligen Vorgänger
gesetzt und an dieser Stelle weitergemacht. 

\input{MemmoryManagment.tex} 
\input{Benchmark.tex} 

	


		

\end{document}
