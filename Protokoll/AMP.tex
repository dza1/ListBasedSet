\documentclass[10pt,a4paper,titlepage,oneside]{article}
\usepackage{LabProtocol}
\usepackage{tikz}
\usepackage{enumitem}
\usepackage{hyperref} 

\usepackage{wrapfig}
\usepackage{multirow}
\usepackage{tabularx}
\usepackage[naustrian]{babel}
\usepackage{float}
\usepackage{todonotes}
\usepackage{fontawesome}
\usepackage{subfig}

\renewcommand{\arraystretch}{1.5}

\usetikzlibrary{arrows,automata} 

\exercise{}

% enter your data here
\authors{
	Daniel Zainzinger, Matr. Nr. 11777778 \\Noah Bruns, Matr. Nr. 11777778\par
	{\small e11777778@student.tuwien.ac.at\\ e11777778@student.tuwien.ac.at} \par
}


\begin{document} 

\maketitle  
 
\tableofcontents
\newpage  
\section{Einleitung}
Für das Programmieren mit mehreren Prozessoren ist es oft erforderlich, eine gemeinsame Datenstruktur zu verwenden. 
Eine möglichkeit ist List based Set. Dabei handelt es sich um eine Liste, bei welcher jedes Element einen Key besitzt.
Dieser Key ist eindeutig und die gesamte Liste ist anhand des Schlüssel sortiert. 
Um das Testen und Benchmarken der Datenstrukturen einfach zu halten, werden nur positive Integer Werte in die Datenstruktur eingefügt (siehe \ref{bench:aufbau}). Es gibt mehrere Optionen für die Implementatierung einer solchen Liste. In Folgendem Kapitel werden 5 verschiedene Implementirungen vergestellt die verschidenene Techniken verwenden um die Synchronisierung und den sicheren Zugriff der gemeinsamen Datenstruktur sichern.

\begin{figure}[H]
	\centering 
	\begin{tikzpicture}
		\node[draw,circle,minimum size=1cm,inner sep=0pt] at (0,0) {$- \infty$};
		\draw[->] (0.5,0) -- (1.5,0);
		\node[draw,circle,minimum size=1cm,inner sep=0pt] at (2,0) {$3$};
		\draw[->] (2.5,0) -- (3.5,0);
		\node[draw,circle,minimum size=1cm,inner sep=0pt] at (4,0) {$5$};
		\draw[->] (4.5,0) -- (5.5,0);
		\node[draw,circle,minimum size=1cm,inner sep=0pt] at (6,0) {$8$};
		\draw[->] (6.5,0) -- (7.5,0);
		\node[draw,circle,minimum size=1cm,inner sep=0pt] at (8,0) {$10$};
		\draw[->] (8.5,0) -- (9.5,0);
		\node[draw,circle,minimum size=1cm,inner sep=0pt] at (10,0) {$\infty$};
	\end{tikzpicture}
	\caption{Aufbau der Liste}
	\label{tik:list}
\end{figure}

In der Abbildung \ref{tik:list} wird dargestellt wie eine solche Liste aussieht. Am Anfang und am Ende befinden sich 2 Nodes $-\infty$ und $\infty$ die den Anfang und das Ende der Liste markieren. Dazwischen befinden sich in sortierter Reihenfolge die eingefügten Keys.

Jede der Implementierungen enthält 3 Methoden die mit denen die Liste bearbeitet werden kann:

\begin{table}[H]
    \begin{tabularx}{\textwidth}{lX}
        \textit{add} & Fügt ein Elemet in die Liste ein. Falls dieses schon enthalten ist gibt die Methode \textit{false} zurück sonst \textit{true}. \\
        \textit{contains} & Wenn das Element in der Liste gefunden wurde gibt diese Methode \textit{true} oder sonst \textit{false} zurück. \\
        \textit{remove} & Diese Methode entfernt einen Key aus der Liste und gibt \textit{true} zurück. Falls der Key nicht in der Liste vorhanden ist wird \textit{false} zurückgegeben. \\
    \end{tabularx}
\end{table}


\input{Implementations.tex}

\subsection{Verbesserungen}
\label{subsec:impr}
In der \textit{find} Funktion wird für das Auslinken eines Nodes wird ein Compare and Swap(CAS) verwendet. Falls dies fehlschlägt, 
weil z.b. der Node zum beispiel bereits ausgelinkt wurde,
wird wieder beim Listenkopf begonnen. Um dieses Verhalten zu verbessern, wurde in \textit{Lock\_free\_impr.cpp} folgendes implementiert:\\
Es wird immer der alte \textit{predecessor} gespeichert. Sollte CAS fehlschlagen, wird überprüft ob der alte \textit{predecessor}
zum auslinken markiert wurde. Ist dies der Fall, werden \textit{predecessor, current} und \textit{successor} auf den jeweiligen Vorgänger
gesetzt und an dieser Stelle weitergemacht. 

\input{MemmoryManagment.tex}
\input{Benchmark.tex} 
\input{Results.tex} 

	


		

\end{document}
